# PCIe Descriptor Formats Reference

Quick reference for CQ/CC/RQ/RC descriptor bit layouts used by Xilinx UltraScale+ PCIe IP Core.

---
## Key Concept: AXI Descriptors = Pre-Parsed TLPs

**The PCIe core translates between raw TLP (Transaction Layer Packet) bytes on PCIe lanes and structured AXI-Stream descriptors.**

```
PCIe Lanes (TLP bytes) ←→ [PCIe IP Core] ←→ AXI-Stream (Descriptors)
        ↑                                              ↑
   Physical layer                              User logic interface
   (PHY, encoding)                             (Clean bit fields)
```

---

## CQ (Completer Request) Descriptor - 256 bits

**Direction:** PCIe Core → User Logic
**Purpose:** Host requests (reads/writes) to device registers

| Bit Range | Field        | Description                                        |
| --------- | ------------ | -------------------------------------------------- |
| [1:0]     | Address Type | 00=untranslated, 10=translated (with IOMMU)        |
| [63:2]    | Address      | Byte address (DWORD aligned, bits [1:0] always 00) |
| [74:64]   | DWORD Count  | How many 32-bit words (e.g., 2 = 64-bit access)    |
| [78:75]   | Request Type | 0000=MRd, 0001=MWr, 0010=IORd, 0011=IOWr           |
| [95:80]   | Requester ID | Host Bus:Dev:Func (e.g., 00:00.0 = 0x0000)         |
| [103:96]  | Tag          | Transaction ID (must echo in completion)           |
| [127:104] | Metadata     | Completer ID, BAR ID, TC, Attr, etc.               |
| [159:128] | Data DW0     | First 32-bit write data (for Memory Write)         |
| [191:160] | Data DW1     | Second 32-bit write data                           |
| [255:192] | Data DW2-3   | Additional write data (for >64-bit writes)         |

**Critical Note:** Write data is at \[191:128], NOT \[127:64]! This is a common mistake.

### TLP to CQ Mapping

**CQ AXI Descriptor (PCIe core extracts and reorganizes):**
```verilog
// Core maps TLP fields to structured descriptor:
m_axis_cq_tdata[78:75]   ← TLP Header Fmt[1:0] + Type[4:0] (compressed)
m_axis_cq_tdata[74:64]   ← TLP Header Length[9:0]
m_axis_cq_tdata[63:2]    ← TLP Header Address[63:2]
m_axis_cq_tdata[95:80]   ← TLP Header Requester_ID[15:0]
m_axis_cq_tdata[103:96]  ← TLP Header Tag[7:0]
m_axis_cq_tdata[159:128] ← TLP Data Payload DW0
m_axis_cq_tdata[191:160] ← TLP Data Payload DW1
```
---

## CC (Completer Completion) Descriptor - 256 bits

**Direction:** User Logic → PCIe Core
**Purpose:** Respond to host read requests with data

| Bit Range | Field         | Description                                      |
| --------- | ------------- | ------------------------------------------------ |
| [2:0]     | Reserved      | Set to 0                                         |
| [42:3]    | Lower Address | Bits [6:0] of byte address (from request)        |
| [54:43]   | Byte Count    | Remaining bytes in completion                    |
| [74:64]   | DWORD Count   | How many DWORDs in this completion               |
| [77:75]   | Status        | 000=SC (success), 001=UR, 010=CRS, 100=CA        |
| [95:80]   | Completer ID  | Your device Bus:Dev:Func                         |
| [127:96]  | **CRITICAL**  | {Byte Count[11:0], Tag[7:0], Requester ID[15:0]} |
| [159:128] | Data DW0      | First 32-bit read data                           |
| [191:160] | Data DW1      | Second 32-bit read data                          |
| [255:192] | Data DW2-3    | Additional read data                             |

**CRITICAL WARNING:** Bits [127:96] must contain `{byte_count, tag, requester_id}` from the CQ request. If wrong, host will timeout!
### Completion Status Codes
- `000`: SC (Successful Completion) - **Use this for normal reads**
- `001`: UR (Unsupported Request)
- `010`: CRS (Configuration Request Retry Status)
- `100`: CA (Completer Abort)

### TLP to CC Mapping

**TLP Generated by PCIe Core (Completion with Data):**
```
Header DW0: 0x4A000002  // Fmt=010 (3DW+data), Type=01010 (CplD), Length=2
Header DW1: 0x...       // Completer ID + Byte Count (lower bits)
            Status=000 (SC) at bits [15:13]
            BCM=0, Byte Count[11:0]=8
Header DW2: 0x0000AB00  // Requester ID=0x0000, Tag=0xAB, Lower Addr
Data   DW0: 0xCAFEBABE  // Low 32 bits of read data
Data   DW1: 0xDEADBEEF  // High 32 bits of read data
```

---

## RQ (Requester Request) Descriptor - 256 bits

**Direction:** User Logic → PCIe Core
**Purpose:** FPGA initiates DMA read/write to host memory

| Bit Range | Field        | Description                                  |
| --------- | ------------ | -------------------------------------------- |
| [1:0]     | Address Type | 00=untranslated, 10=translated (IOMMU)       |
| [63:2]    | Address      | Host memory address (64-bit)                 |
| [74:64]   | DWORD Count  | How many DWORDs to read/write                |
| [78:75]   | Request Type | 0000=MRd64, 0001=MWr64, 0010=IORd, 0011=IOWr |
| [95:80]   | Requester ID | Your device Bus:Dev:Func                     |
| [103:96]  | Tag          | Transaction ID (for matching RC completions) |
| [127:104] | Metadata     | First/Last BE, TC, Attr, TPH, etc.           |
| [255:128] | Write Data   | Payload (for Memory Write)                   |

### Request Type for DMA
- `0000`: Memory Read 64-bit (MRd64) - For fetching descriptors/data
- `0001`: Memory Write 64-bit (MWr64) - For writing packets/completions

---

## RC (Requester Completion) Descriptor - Variable

**Direction:** PCIe Core → User Logic
**Purpose:** Host responds to FPGA's DMA read requests

| Bit Range | Field         | Description                        |
| --------- | ------------- | ---------------------------------- |
| [11:0]    | Byte Count    | Remaining bytes in completion      |
| [14:12]   | Status        | 000=SC, 001=UR, 010=CRS, 100=CA    |
| [31:15]   | Metadata      | Requester/Completer ID, etc.       |
| [42:32]   | DWORD Count   | How many DWORDs in this completion |
| [74:43]   | More metadata | TC, Attr, etc.                     |
| [255:75]  | Read Data     | Payload from host memory           |

### Tag Matching
When FPGA issues RQ read with Tag=0x01, the RC completion will have the same Tag=0x01. Use this to match requests to responses.


---

## Common Pitfalls

### 2. Forgetting to Echo Tag/Requester in CC
```verilog
// WRONG: Host will timeout
s_axis_cc_tdata[127:96] = 32'h0;  // Random values

// CORRECT: Must match CQ request
s_axis_cc_tdata[127:96] = {saved_byte_count, saved_tag, saved_requester_id};
```

### 3. Wrong Address Alignment
```verilog
// WRONG: Using byte address directly
s_axis_rq_tdata[63:0] = 64'h1234_5678_9ABC_0001;  // Bits [1:0] should be 00

// CORRECT: Shift byte address by 2 (DWORD aligned)
s_axis_rq_tdata[63:2] = byte_address[63:2];
s_axis_rq_tdata[1:0]  = 2'b10;  // Address type
```

---

## Address Type Field

| Value | Meaning | When to Use |
|-------|---------|-------------|
| `00` | Untranslated | No IOMMU, direct physical addressing (dangerous!) |
| `10` | Translated | With IOMMU (safe, recommended for DMA) |

**Always use `10` (translated) for DMA to get IOMMU protection.**

---
## Descriptor Size Summary

| Interface | Direction | Descriptor Size | Data Location | Notes |
|-----------|-----------|-----------------|---------------|-------|
| CQ | Core → User | 256 bits | [191:128] (write data) | Receives host requests |
| CC | User → Core | 256 bits | [191:128] (read data) | Sends read completions |
| RQ | User → Core | 256 bits | [255:128] (write data) | Initiates DMA |
| RC | Core → User | Variable | [255:75+] (read data) | Receives DMA completions |

---

## Quick Reference: What Goes Where

### For Register Writes (CQ)
```
m_axis_cq_tdata[78:75]   = 4'b0001        // Memory Write
m_axis_cq_tdata[63:2]    = register_addr  // Which register
m_axis_cq_tdata[191:128] = write_data     // Data to write
```

### For Register Reads (CQ → CC)
```
// CQ side:
m_axis_cq_tdata[78:75]  = 4'b0000      // Memory Read
m_axis_cq_tdata[103:96] = tag          // Save this!
m_axis_cq_tdata[95:80]  = requester_id // Save this!

// CC side:
s_axis_cc_tdata[127:96]  = {byte_count, tag, requester_id}  // MUST match CQ
s_axis_cc_tdata[191:128] = read_data                        // Data to return
```

### For DMA Writes (RQ)
```
s_axis_rq_tdata[78:75]   = 4'b0001        // MWr64
s_axis_rq_tdata[63:2]    = host_addr >> 2 // Host memory address
s_axis_rq_tdata[255:128] = dma_payload    // Data to write
```

### For DMA Reads (RQ → RC)
```
// RQ side:
s_axis_rq_tdata[78:75]  = 4'b0000     // MRd64
s_axis_rq_tdata[103:96] = tag         // For matching RC
s_axis_rq_tdata[63:2]   = host_addr   // Where to read from

// RC side:
m_axis_rc_tdata[...]     = tag        // Match with RQ tag
m_axis_rc_tdata[255:75+] = read_data  // Data from host
```

---

## Complete Transaction Example: TLP ↔ AXI

### Host Reads 64-bit Register (Full Stack View)

**1. Host CPU Issues Read**
```cpp
volatile uint64_t* reg = (uint64_t*)(bar0 + 0x08);
uint64_t value = *reg;  // CPU stalls here, waiting for PCIe read
```

**2. CPU → Root Complex → TLP on PCIe Lanes**
```
Memory Read Request TLP (3 DWORDs, no data):
  DW0: 0x00000002  // Fmt=000 (3DW, no data), Type=00000 (MRd), Length=2
  DW1: 0x0000AB00  // Requester ID=0x0000, Tag=0xAB, BE=0xFF
  DW2: 0xF7C00008  // Address = BAR0 base + 0x08
```

**3. PCIe Core Receives TLP → CQ Descriptor**
```verilog
m_axis_cq_tdata[78:75]  = 4'b0000      // Memory Read (from TLP Fmt/Type)
m_axis_cq_tdata[74:64]  = 11'h002      // 2 DWORDs (from TLP Length)
m_axis_cq_tdata[63:2]   = 62'h...02    // Address 0x08 >> 2 (from TLP Address)
m_axis_cq_tdata[103:96] = 8'hAB        // Tag (from TLP)
m_axis_cq_tdata[95:80]  = 16'h0000     // Requester ID (from TLP)
m_axis_cq_tvalid = 1'b1;
```

**4. User Logic Processes CQ**
```verilog
if (m_axis_cq_tvalid && m_axis_cq_tready) begin
    saved_tag <= cq_tag;               // 0xAB
    saved_requester_id <= cq_requester_id;  // 0x0000
    saved_reg_addr <= reg_addr;        // 0x1 (ID register)
    state <= ST_COMPLETE;
end
```

**5. User Logic Builds CC Descriptor**
```verilog
s_axis_cc_tdata[191:128] = 64'hDEADBEEFCAFEBABE  // ID register value
s_axis_cc_tdata[127:116] = 12'h008               // Byte count = 8
s_axis_cc_tdata[115:108] = 8'hAB                 // Tag (must match CQ!)
s_axis_cc_tdata[107:92]  = 16'h0000              // Requester ID (must match!)
s_axis_cc_tdata[77:75]   = 3'b000                // Status = SC (success)
s_axis_cc_tdata[74:64]   = 11'h002               // 2 DWORDs
s_axis_cc_tvalid = 1'b1;
```

**6. PCIe Core Generates Completion TLP**
```
Completion with Data TLP (3 DWORDs header + 2 DWORDs data):
  DW0: 0x4A000002  // Fmt=010 (3DW+data), Type=01010 (CplD), Length=2
  DW1: 0x...       // Completer ID, Status=000, Byte Count=8
  DW2: 0x0000AB08  // Requester ID=0x0000, Tag=0xAB, Lower Addr
  DW3: 0xCAFEBABE  // Data low 32 bits
  DW4: 0xDEADBEEF  // Data high 32 bits
```

**7. TLP Travels PCIe Lanes → Root Complex**

**8. Root Complex Matches Tag=0xAB to Pending Read**

**9. CPU Load Instruction Completes**
```cpp
// value = 0xDEADBEEFCAFEBABE (from completion data)
printf("Read value: 0x%016lx\n", value);
```

**Total Latency: ~500-1000 ns**

### Key Takeaways from This Flow

1. **TLP is the "wire format"** - Raw bytes on PCIe lanes
2. **AXI is the "user interface"** - Structured descriptors for HDL
3. **PCIe Core is the translator** - Converts between TLP ↔ AXI
4. **You work with AXI** - Never need to parse raw TLP bytes
5. **Tag/ID matching is critical** - Host uses these to route completions
6. **Posted vs Non-Posted**:
   - Write (posted): No completion TLP, ~100-200 ns
   - Read (non-posted): Requires completion TLP, ~500-1000 ns

---

